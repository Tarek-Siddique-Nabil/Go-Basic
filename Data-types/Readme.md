#### প্রশ্নঃ- ডাটা টাইপস বিষয়টি আসলে কি আর কেন ডাটা টাইপ্স দরকার ?

- ধরো তুমি তোমার কোডে একটি ভেরিয়েবল নিলে যেমন `var x = 10` । তুমি যে এখানে ভেরিয়েবল এর `x` এর মান `১০` দিলে এই `১০ `কিন্তু একটি নাম্বার । মূলত তোমার ভেরিয়েবল কোন ধরণের ডাটা রাখতে পারবে তা তুমি ভেরিয়েবলে জানিয়ে দেওয়াকেই ভেরিয়েবল টাইপ ডিক্লেরেশন বা ডাটা টাইপস বলে । এখন যদি আমরা আমাদের ভেরিয়েবল x এর ডাটা টাইপ্স জানিয়ে দিতে চাই তাহলে আমরা লেখতে পারি `var x int = 10` । `int` লেখেছি ফলে `x` ভেরিয়েবলটি এখন শুধুমাত্র পূর্নসংখ্যা রাখতে পারবে ভেরিয়েবল এর ডাটা হিসাবে । উক্ত পদ্ধতি ছাড়া আরো বিভিন্ন উপায়ে ভেরিয়েবল এর ডাটা টাইপ্স জানানো যায় কিছুক্ষণ পড়েই আমরা তা সম্নধে জানতে পারবো ।

  **ডাটা টাইপস কেন দরকার?**

  ডাটা টাইপস মূলত প্রোগ্রামে তিনটি গুরুত্বপূর্ণ সুবিধা দেয়:

  1. **নির্ভুলতা**: ডাটা টাইপ ব্যবহার করলে ভেরিয়েবল আগে থেকেই জানতে পারে কোন ধরনের ডাটা সে ধারণ করবে। যদি ভুল ডাটা দেয়া হয়, তবে কোড কম্পাইলের সময়ই ত্রুটি (error) দেখাবে।

  2. **মেমোরি কন্ট্রোল**: আমরা যদি একটি ভেরিয়েবল এর ক্ষেত্রে ডাটা টাইপ লেখি int8 তবে এই ক্ষেত্রে ভেরিয়েবলটি মেমোরি / র‍্যাম এর মাত্র ১ বাইট / ৮ বিট জায়গা নেবে কিন্তু আমরা যদি int64 লেখি তবে এই ক্ষেত্রে ভেরিয়েবলটি মেমোরীর ৮ বাইট/ ৬৪ বাইট জায়গা নেবে।

  3. **কোডের রিডেবিলিটি**: ডাটা টাইপের সাহায্যে কোড পড়া ও বুঝা সহজ হয়। যখন তুমি ভেরিয়েবলের টাইপ নির্দিষ্ট করো, তখন বোঝা যায় সে কী ধরণের ডাটা ধারণ করবে।

#### প্রশ্নঃ- Golang এ ডাটা টাইপস কয় ধরনের ?

- মুলত Golang এর ডাটা টাইপ্স ২ ধরণের
  1. Basic Types
  2. Composite Types

```
├── Basic Types
│   ├── Integers
│   │   ├── Signed (int,int8,int16,int32,int64)
│   │   └── Unsigned (uint,uint8,uint16,uint32,uint64,uintptr)
│   ├── Floats
│   │   ├── float32
│   │   └── float64
│   ├── Complex Numbers
│   │   ├── complex64
│   │   └── complex128
│   │
│   ├── Byte
│   ├── Rune
│   ├── String
│   └── Boolean
├── Composite Types
│   ├── Collection/Aggregation or Non-Reference Types
│   │   ├── Arrays
│   │   └── Structs
│   ├── Reference Types
│   │   ├── Slices
│   │   ├── Maps
│   │   ├── Channels
│   │   ├── Pointers
│   │   └── Function/Methods
│   └── Interface
|       └── Special case of empty Interface

```

### **Basic Types**

#### **Integers (পূর্ণসংখ্যা)**

পূর্ণসংখ্যা টাইপগুলি দুটি ভাগে বিভক্ত: Signed (চিহ্নিত) এবং Unsigned (অচিহ্নিত)।

##### **Signed Integers (চিহ্নিত পূর্ণসংখ্যা)**

- **`int`**: প্ল্যাটফর্মের উপর নির্ভর করে আকার পরিবর্তন হতে পারে (32 বা 64-বিট)।
- **`int8`**: ৮-বিট সাইনড পূর্ণসংখ্যা, মান সীমা: -128 থেকে 127।
- **`int16`**: ১৬-বিট সাইনড পূর্ণসংখ্যা, মান সীমা: -32,768 থেকে 32,767।
- **`int32`**: ৩২-বিট সাইনড পূর্ণসংখ্যা, মান সীমা: -2,147,483,648 থেকে 2,147,483,647।
- **`int64`**: ৬৪-বিট সাইনড পূর্ণসংখ্যা, মান সীমা: -9,223,372,036,854,775,808 থেকে 9,223,372,036,854,775,807।

**ব্যবহার:** চিহ্নিত পূর্ণসংখ্যা ধনাত্মক ও ঋণাত্মক উভয় মান ধারণ করতে পারে। যেমন, বয়স, তাপমাত্রা ইত্যাদি।

##### **Unsigned Integers (অচিহ্নিত পূর্ণসংখ্যা)**

- **`uint`**: প্ল্যাটফর্মের উপর নির্ভর করে আকার পরিবর্তন হতে পারে।
- **`uint8`**: ৮-বিট আনসাইনড পূর্ণসংখ্যা, মান সীমা: 0 থেকে 255।
- **`uint16`**: ১৬-বিট আনসাইনড পূর্ণসংখ্যা, মান সীমা: 0 থেকে 65,535।
- **`uint32`**: ৩২-বিট আনসাইনড পূর্ণসংখ্যা, মান সীমা: 0 থেকে 4,294,967,295।
- **`uint64`**: ৬৪-বিট আনসাইনড পূর্ণসংখ্যা, মান সীমা: 0 থেকে 18,446,744,073,709,551,615।
- **`uintptr`**: পয়েন্টার স্টোর করার জন্য ব্যবহৃত হয়, এর আকার প্ল্যাটফর্মের উপর নির্ভর করে।

**ব্যবহার:** অচিহ্নিত পূর্ণসংখ্যা শুধুমাত্র ধনাত্মক মান ধারণ করে। এটি সাধারণত তখন ব্যবহার করা হয় যখন নিশ্চিত যে মান ঋণাত্মক হবে না, যেমন জনসংখ্যা, সূচক ইত্যাদি।

#### **Floats (ভাসমান বিন্দু সংখ্যা)**

- **`float32`**: ৩২-বিট ফ্লোটিং পয়েন্ট সংখ্যা, দশমিকের পরে প্রায় ৬-৭ ডিজিট সঠিকতা প্রদান করে।
- **`float64`**: ৬৪-বিট ফ্লোটিং পয়েন্ট সংখ্যা, দশমিকের পরে প্রায় ১৫-১৬ ডিজিট সঠিকতা প্রদান করে।

**ব্যবহার:** দশমিক সংখ্যা বা ভগ্নাংশ ধারণ করতে ব্যবহৃত হয়। যেমন, ওজন, উচ্চতা, গতি ইত্যাদি।

#### **Complex Numbers (জটিল সংখ্যা)**

- **`complex64`**: বাস্তব এবং কাল্পনিক উভয় অংশ `float32` টাইপের।
- **`complex128`**: বাস্তব এবং কাল্পনিক উভয় অংশ `float64` টাইপের।

**ব্যবহার:** জটিল গণিত বা সিগন্যাল প্রসেসিং-এ ব্যবহৃত হয়।

#### \*_Byte_

- **`byte`** হল **`uint8`**-এর আরেকটি নাম। এটি সাধারণত অক্ষর বা ছোট ডাটা স্টোর করতে ব্যবহৃত হয়।

**ব্যবহার:** ফাইল পড়া বা লেখা, বাইট স্তরের অপারেশন ইত্যাদি।

#### **Rune**

- **`rune`** হল **`int32`**-এর আরেকটি নাম। এটি ইউনিকোড কোড পয়েন্ট ধারণ করতে ব্যবহৃত হয়।

**ব্যবহার:** ইউনিকোড অক্ষর বা আন্তর্জাতিক টেক্সট প্রসেসিং।

#### **String (স্ট্রিং)**

- **`string`** টাইপটি টেক্সট ডাটা ধারণ করে। এটি অক্ষরগুলির একটি সিকোয়েন্স।

**ব্যবহার:** বাক্য, শব্দ, বা টেক্সট ডাটা সংরক্ষণে ব্যবহৃত হয়।

#### **Boolean (বুলিয়ান)**

- **`bool`** টাইপের দুটি মান হতে পারে: `true` বা `false`।

**ব্যবহার:** শর্ত পরীক্ষা, লজিক্যাল অপারেশন।

---

### **Composite Types**

Composite Types হল একাধিক ডাটা টাইপের সমন্বয়ে গঠিত। এগুলি ডাটা স্ট্রাকচার তৈরিতে ব্যবহৃত হয়।

#### **Collection/Aggregation or Non-Reference Types**

##### **Arrays (অ্যারে)**

- নির্দিষ্ট আকারের এবং একই টাইপের এলিমেন্টের সংগ্রহ। একবার অ্যারের আকার নির্ধারণ হয়ে গেলে, তা পরিবর্তন করা যায় না।

  **উদাহরণ:**

  ```go
  var arr [5]int // ৫ টি int টাইপের এলিমেন্ট ধারণ করতে পারবে
  arr[0] = 10
  arr[1] = 20
  ```

##### **Structs**

- বিভিন্ন টাইপের ফিল্ড নিয়ে গঠিত কাস্টম ডাটা টাইপ । স্ট্রাক্ট ব্যবহার করে ডাটা মডেল করা হয় ।
  **উদাহরণ**
  ```go
     type user struct{
       name string
       age string
     }
     var x user
     x.name = "Nabil"
     x.age = 19
  ```

##### **Slice**

- স্লাইচ হলো ডায়নামিক আকারের লিস্ট । এটি অ্যারের উপর ভিত্তি করে তৈরি , তবে এর আকার পরিবর্তনযোগ্য ।
  **উদাহরণ**

```go

var numbers []int
numbers = append(numbers,10)
numbers = append(numbers,20)


```
